choose_question_diss <- function (X, D, indices, vec_quali = c(), w = rep(1. / nrow(X), nrow(X)), 
                             vec_order) {
  l = length(indices)
  #if (l <= 1)
  #   stop(' choose_question : cannot divide singleton or empty sets')
  p <- dim(X)[2]
  inert_max <- 0
  c_max <- 0
  j_max <- -1
  A_l_max <- c()
  A_l_c_max <- c()
  nb_quanti <- p - sum(vec_quali) 
  nb_quali <- length(vec_quali)
  
  if (l > 1) 
  {
    # binary question with the quantitative variables
    for (j in seq_len(nb_quanti)) 
    {
      cut_vals <- compute_cut_values(X[indices, j])
      inerts <- sapply(cut_vals, function(l) { between_diss(D, indices[X[indices, j] <= l], indices[X[indices, j] > l], w) }) 
      l_max <- which.max(inerts) 
      if ( length(l_max)== 1 && inerts[l_max] >inert_max) 
      { 
        j_max <- j 
        c_max <- list(type = "quanti", value = cut_vals[l_max])
        inert_max <- inerts[l_max]
        A_l_max = indices[X[indices, j_max] <= c_max$value]
        A_l_c_max = indices[X[indices, j_max] > c_max$value]
      } 
    }
    start_offsets = c(0, cumsum(vec_quali)) + nb_quanti 
    # binary question with the quantitative variables
    for(j in seq_len(nb_quali)) 
    {
      nb_mod = vec_quali[[j]] 
      to_keep = seq_len(nb_mod)[apply(X[indices, start_offsets[[j]] + seq_len(nb_mod)],2,sum) != 0]
      if (vec_order[j]==TRUE)
      {
        biparts <- list()
        if (length(to_keep) >1)
          biparts = lapply(1:(length(to_keep)-1),function(x){to_keep[1:x]})
      } else 
        biparts = bipart(length(to_keep))
      
      nb_biparts = length(biparts)
      
      select_quali <- function(bp_index) 
      {
        A_l <- indices[apply(as.matrix(X[indices, start_offsets[[j]] + to_keep[biparts[[bp_index]]]] == 1), 1, any)]
        A_l_c <- indices[ apply(as.matrix(X[indices, start_offsets[[j]] + to_keep[biparts[[bp_index]]]] == 0), 1, all)]
        return(between_diss(D, A_l, A_l_c, w))
      }
      
      inerts <- lapply(seq_len(nb_biparts), select_quali)
      l_max <- which.max(inerts)
      if (length(l_max) >=1 && inerts[[l_max]] > inert_max) 
      {
        inert_max <- inerts[[l_max]]
        value <- to_keep[biparts[[l_max]]]
        bipart_c <- setdiff(to_keep, value) 
        c_max <- list(type = "quali", value = list(bipart=value,bipart_c = bipart_c))
        j_max <- j 
        A_l_max <- indices[apply(as.matrix(X[indices, start_offsets[[j]] + c_max$value$bipart] == 1), 1, any)]
        A_l_c_max <- indices[apply(as.matrix(X[indices, start_offsets[[j]] + c_max$value$bipart] == 0), 1, all)]
      }
    }
  }
  return (list(inert = inert_max, A_l = A_l_max, A_l_c = A_l_c_max, cut_ind = j_max, cut_val = c_max))
}

# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

bipart <- function(n) {
    .Call('divclust_bipart', PACKAGE = 'divclust', n)
}
